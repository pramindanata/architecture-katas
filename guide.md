# Guide

> This guide is generated by using ChatGPT. Prompt:
>
> how to do an architecture kata alone to practice system design in a structured way? I can get some kata from web such as <https://www.architecturalkatas.com/> but not sure how to do it.
> currently, i think the following approach
>
> 1. Discover the functional and non functional requirements -> using event storming or other approaches.
> 2. Determine the important architecture characteristics based on architecture characteristic card
> 3. Design the c1 & c2 diagrams

Thatâ€™s a really good start â€” and youâ€™re already thinking in a *structured* and *DDD-informed* way. Doing **architecture katas solo** is one of the best ways to sharpen your system design intuition and communication skills.

Letâ€™s refine your approach so you can systematically go from a problem statement to a complete architecture decision record.

---

## ğŸ§­ Overall Goal

Treat the kata like a **real architecture process**:

* Go from ambiguity â†’ clarity
* Justify trade-offs
* Produce clear, communicable artifacts (diagrams + rationale)
* Reflect on what youâ€™d improve

The trick when youâ€™re alone: **simulate team collaboration** by explicitly writing down your reasoning as if you were explaining it to others.

---

## âš™ï¸ Recommended 7-Step Process for Solo Architecture Kata

### **1. Clarify the Problem**

**Goal:** Make the problem statement unambiguous.

**Activities:**

* Read the kata prompt carefully.
* Write down assumptions, ambiguities, and open questions.
* State what youâ€™ll assume (e.g., â€œassume user base will grow to 1M monthly usersâ€).
* Identify **actors** and **main workflows**.

ğŸ“ *Deliverable:* Problem statement summary + assumptions list.

---

### **2. Discover Requirements**

**Goal:** Capture functional & non-functional requirements.

**Activities:**

* Extract **functional requirements** â†’ what the system *must do* (features, use cases).
* Derive **non-functional requirements (NFRs)** â†’ scalability, latency, availability, cost, maintainability, etc.
* Classify each NFR with **priority and justification**.

ğŸ§© *Tools you can use:*

* Event storming (for domain exploration)
* Quality Attribute Scenarios (for NFRs, e.g., â€œThe system shall recover from failure in < 1 minuteâ€)

ğŸ“ *Deliverable:* Requirements list, prioritized.

---

### **3. Identify Architecture Characteristics**

**Goal:** Find the key â€œarchitectural drivers.â€

**Activities:**

* Choose 3â€“5 critical quality attributes (performance, availability, scalability, modifiability, etc.).
* Use something like **Architecture Characteristics Cards** to help pick and define them.
* Describe **why** each characteristic matters for this domain.

ğŸ“ *Deliverable:* Table of characteristics + rationale.

---

### **4. Model the Domain (if business-heavy kata)**

**Goal:** Understand the problem domain conceptually.

**Activities:**

* Identify main subdomains (core, supporting, generic).
* Sketch a context map or bounded context diagram.
* Define entities and key domain flows.

ğŸ“ *Deliverable:* Domain model / bounded context diagram (optional but valuable).

---

### **5. Design the Architecture**

**Goal:** Create a conceptual and logical architecture.

**Activities:**

* Start at **C1** (System Context): Define actors, external systems, and boundaries.
* Move to **C2** (Container): Identify containers (API, DB, front-end, background workers, etc.).
* Optionally go to **C3** (Component) for deeper exploration.
* Define communication protocols (REST, event-driven, etc.).
* Make explicit your **architectural decisions and trade-offs** (record them as ADRs).

ğŸ§© *Tools you can use:*

* C4 diagrams (draw.io, Structurizr, Excalidraw)
* ADR markdown files (to explain decisions)

ğŸ“ *Deliverable:* C1 + C2 (and maybe C3) diagrams + ADRs.

---

### **6. Validate Against Requirements**

**Goal:** Ensure your design meets what you set out to do.

**Activities:**

* Check how each architecture characteristic is addressed (e.g., scalability â†’ load balancer + horizontal scaling).
* Perform a small **trade-off analysis** (e.g., â€œWhy event-driven vs. synchronous?â€).
* Consider alternative options (list 1 or 2).

ğŸ“ *Deliverable:* Table mapping requirements â†’ design decisions.

---

### **7. Reflect and Document Learnings**

**Goal:** Turn the kata into a learning artifact.

**Activities:**

* Write down what you learned:

  * Which decisions felt easy vs. hard?
  * What patterns emerged?
  * How would you explain this design to a junior engineer or stakeholder?
* Optionally present it to a friend or record yourself explaining it â€” thatâ€™s excellent practice.

ğŸ“ *Deliverable:* Architecture summary + reflection log.

---

## ğŸ“„ Example Folder Structure

```txt
my-architecture-kata/
â”‚
â”œâ”€ 01_problem_statement.md
â”œâ”€ 02_requirements.md
â”œâ”€ 03_arch_characteristics.md
â”œâ”€ 04_domain_model.png
â”œâ”€ 05_c1_context_diagram.png
â”œâ”€ 06_c2_container_diagram.png
â”œâ”€ 07_adr_scalability_choice.md
â””â”€ 08_reflection.md
```

---

## ğŸ§  Optional Enhancements

* Use **ATAM** (Architecture Tradeoff Analysis Method) for deeper evaluation.
* Revisit the same kata later using a different style (e.g., monolith vs. microservices).
* Join community discussions (Architectural Katas Slack/Discord) and compare your solution.
